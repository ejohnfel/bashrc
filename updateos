#!/bin/bash

########################################################
# [AUTOMATED-INSERT-MARKER]
# Author Eric Johnfelt
# Date 6/22/2018

declare -a UPDCMDS
MYGITREP=ejohnfel
BASHRCGIT="https://github.com/ejohnfel/bashrc"
BASHRCVERSION="201809221024"
ISNAT=0
INTERNIP=`hostname -I`
EXTERNIP="UNKNOWN"
FIXCHECK=""
PREFIX=""
LOCATION="internal"
MYDOMAIN="digitalwicky.biz"
SAYINGS="/srv/storage/data/waiting.txt"

# Set prefix
function SetPrefix()
{
	if [ ! "${LOGNAME}" = "root" ]; then
		PREFIX="sudo"
	fi
}

# SSH Setup Stuff
function SSHSetup()
{
	NOAGENT=1

	# Early Exit COnditions
	# If root or one of the big ENV variables exists, do not run
	[ "${LOGNAME}" = "root" ] && return
	[ ! "${SSH_AGENT_PID}" = "" ] && return
	[ ! "${SSH_AUTH_SOCK}" = "" ] && return

	TMP=/tmp/tmp.${RANDOM}

	# Check for existing SSH-AGENT, no need to run more if user is already running one
	ps -u "${LOGNAME}" | grep "ssh-agent" > ${TMP}

	# Check for running SSH-AGENT
	if [ $? = 0 ]; then
		# Agent running, get PID
		PID=$(cut -d" " -f1 "${TMP}" | head -n 1)
		SSH_AGENT_PID=${PID}
		export SSH_AGENT_PID
		NOAGENT=0
	fi

	[ -e ${TMP} ] && rm ${TMP}

	if [ ${NOAGENT} = 1 ]; then
		eval `ssh-agent`

		if [ -e ~/.ssh/id_rsa ]; then
			ssh-add
		fi

		if [ -e ~/.ssh/id_rsa.home ]; then
			ssh-add ~/.ssh/id_rsa.home
		fi

		if [ -e ~/.ssh/id_rsa.work ]; then
			ssh-add ~/.ssh/id_rsa.work
		fi
	fi
}

# Clone Git Repositories From My Account
function mygit()
{
	if [ "${1}" = "-h" ]; then
		echo -e "mygit [clone|push] [repository]"
		echo -e "Enviroment variable $MYGITREP points to username for Repositories"
	else
		case "${1}" in
		"clone")	msg="Cloning from ${MYGITREP}/${2}..." ;;
		"push")		msg="Pushing to ${MYGITREP}/${2}..." ;;
		esac

		echo -e "${msg}"
		git ${1} https://github.com/${MYGITREP}/${2}
	fi
}

# Stupid Tiny Function To Show BASHRC Version
function mybashrc()
{
	if [ "${1}" = "" ]; then
		msg="MyBASHRC Version"
	else
		msg="${@}"
	fi

	echo -e "${msg} : ${BASHRCVERSION}"
}

# Manual Update
function updatemybashrc()
{
	pushd /tmp > /dev/null

	mybashrc "Current Version"

	git clone ${BASHRCGIT}

	cd bashrc

	make clean
	make all
	make update
	sudo make automation

	cd ..

	rm -Rf bashrc

	source ~/.bashrc

	mybashrc "New Version"

	popd > /dev/null
}

# If Syaings/Waitings File Exists, Print A Random Line From File
function RandomSaying()
{
	[ -e "${SAYINGS}" ] && shuf -n1 "${SAYINGS}"
}

# Determine Location of This Machine (and update MYDOMAIN,LOCATION variables)
function DetermineLocation()
{
	# If internal, digitalwicky.biz
	# If external, digitalwicky.net
	# Note, firewall settings may prevent use of resources
	TMP=/tmp/dl.${RANDOM}
	hostname -I > ${TMP}

	while read ipaddr; do
		prefix=`echo ${ipaddr} | cut -d"." -f 1,2`

		case "${prefix}" in
		"192.168")
			LOCATION="internal"
			MYDOMAIN="digitalwicky.biz"
			;;
		*)
			LOCATION="external"
			MYDOMAIN="digitalwicky.net"
			;;
		esac
	done < ${TMP}

	rm ${TMP}
}

# Determine NAT and External IP (NPING/NMAP must be installed, must be able to sudo)
# Sets ${ISNAT}, ${INTERNIP} and ${EXTERNIP} Environment Variables
function DetectNAT()
{
	nping > /dev/null

	if [ ! $? = 1 ]; then
		echo -e "Nping not installed, cannot determine NAT"
		INTERNIP=`hostname -I`
		EXTERNIP="UNKNOWN"
		ISNAT=0

		return 127
	else
		TMP=/tmp/detectnat.${RANDOM}

		sudo nping --ec "public" -c 1 echo.nmap.org > ${TMP}

		INTERNIP=`grep SENT ${TMP} | cut -d" " -f4 | cut -d"[" -f2`
		EXTERNIP=`grep CAPT ${TMP} | cut -d" " -f4 | cut -d"[" -f2`

		if [ "${INTERNIP}" = "${EXTERNIP}" ]; then
			ISNAT=0
		else
			ISNAT=1
		fi

		rm ${TMP}
	fi

	return 0
}

# Show NAT Status
function isnat()
{
	DetectNAT

	if [ ${ISNAT} = 1 ]; then
		echo -e "[=== This host is NAT/PAT'ed"
		echo -e "[=== Internal IP : ${INTERNIP}"
		echo -e "[=== External IP : ${EXTERNIP}"
	else
		echo -e "[=== This host is NOT NAT/PAT'ed"
		echo -e "[=== IP : ${INTERNIP}"
	fi
}

# Determine Package Manager
function GetPackageManager()
{
	apt-get --version > /dev/null

	if [ $? = 0 ]; then
		FIXCHECK="apt-get --just-print upgrade | grep \"upgraded,\""
		UPDCMDS[0]="apt-get -qq update"
		UPDCMDS[1]="apt-get -qq -y upgrade"
		UPDCMDS[2]="apt-get -qq -y dist-upgrade"
		UPDCMDS[3]="apt-get -qq -y autoremove"

		return 1
	fi

	yum --version > /dev/null

	if [ $? = 0 ]; then
		FIXCHECK="yum check-update"
		UPDCMDS[0]="yum check-update"
		UPDCMDS[1]="yum -y update"
		UPDCMDS[2]="yum -y upgrade"
		UPDCMDS[3]="yum -y autoremove"

		return 1
	fi

	rpm --version > /dev/null

	if [ $? = 0 ]; then
		UPDCMDS[0]="rpm update"

		return 0
	fi

	pacman --version > /dev/null

	if [ $? = 0 ]; then
		UPDCMDS[0]="pacman update"

		return 1
	fi

	opkg --version > /dev/null

	if [ $? = 0 ]; then
		UPDCMDS[0]="opkg update"

		return 1
	fi

	dpkg --version > /dev/null

	if [ $? = 0 ]; then
		UPDCMDS[0]="dpkg update"

		return 0
	fi

	echo -e "Cannot determine package manager.. quitting..."

	return 0
}

# Update Package Manager's Database
function UpdateManagerDatabase()
{
	SetPrefix

	GetPackageManager

	echo "Updating Package Manager Database..."
	eval ${PREFIX} ${UPDCMDS[0]} > /dev/null
}

# Check for Existing Updates
function CheckForUpdates()
{
	SetPrefix

	UpdateManagerDatabase

	eval ${PREFIX} ${FIXCHECK}
}

# Apply All Updates
function allupdates()
{
	echo -e "Call updateos from /usr/local/bin from now on..."
	updateos ${@}
}

# Determine This Machines Location
DetermineLocation

# Setup SSH Agent
SSHSetup

# Sayings
RandomSaying
########################################################
# [AUTOMATED-INSERT-MARKER]
# Author Eric Johnfelt
# Date 10/23/2017

# Update OS
function UpdateOS()
{
	PREFIX=""

	if [ ! "${LOGNAME}" = "root" ]; then
		PREFIX=sudo
	fi

	GetPackageManager

	if [ ! "$1" = "-c" ]; then
		echo -e "Beginning Update of ${HOSTNAME}..."
		cmds=${#UPDCMDS[*]}
		index=0

		while [ ${index} -lt ${cmds} ]; do
			eval ${PREFIX} ${UPDCMDS[${index}]}
			index=$((${index} + 1))
		done
	fi

	if [ "$1" = "-c" ]; then
		chkupd
	elif [ "$1" = "-w" ]; then
		read -p "Reboot ${HOSTNAME} (y/n)? "
		[ "${REPLY}" = "y" ] && ${PREFIX} reboot
	elif [ "$1" = "-r" -o "$1" = "-y" ]; then
		read -n 1 -t 30 -p "Rebooting ${HOSTNAME} in 30s, abort (y/n)? "
		[ ! "${REPLY}" = "y" ] && ${PREFIX} reboot
	elif [ "$1" = "-h" -o "$1" = "-s" ]; then
		read -n 1 -t 30 -p "Shutting down ${HOSTNAME} in 30s, abort (y/n)? "
		[ ! "${REPLY}" = "y" ] && ${PREFIX} shutdown -h now
	else
		read -t 60 -p "Reboot ${HOSTNAME} (y/N)? "

		if [ "${REPLY}" = "y" -o "${REPLY}" = "Y" ]; then
			${PREFIX} reboot
		fi
	fi
}


# Determine Hosts Location
DetermineLocation

# Call Update OS To Apply Patches
UpdateOS ${@}
